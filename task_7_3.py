# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек.
# Необходимо создать класс Клетка. В его конструкторе инициализировать параметр,
# соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять:
# увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
#
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.

# Вычитание. Участвуют две клетки. Операцию необходимо выполнять
# только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.

# Умножение. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.

# Деление. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(),
# принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****...,
# где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#


class Call:

    def __init__(self, amount):
        self.amount = amount
        if type(self.amount) != int:
            print(f'Атрибуты класса - количество ячеек в клетке: {self.amount}\n'
                  f'Это не соответсвует требованию - Только целые числа!\n'
                  f'Приведите, пожалуйста, атрибут в соответсвие требованиям')


    def __add__(self, other):
        return f'При объединении клетки получилось ячеек: {self.amount + other.amount}'

    def __sub__(self, other):
        if (self.amount - other.amount) < 0:
            print(f'Невозможно выполнить операцию, так как первый атрибут меньше второго:\n'
                  f'Первый атрибут: {self.amount}\n'
                  f'Второй аптрибут: {other.amount}\n'
                  f'Исправте атрибуты или откажитесь от операции.')
        elif (self.amount - other.amount) == 0:
            print(f'Клетка сдохла. Ячеек: 0')
        else:
            return f'Клетка потеряла ячеек: {other.amount}\n' \
                   f'Теперь клетка содержит ячеек: {self.amount - other.amount}'

    def __mul__(self, other):
        return f'Получилась очень жирная клекта у нее ячеек: {self.amount*other.amount}'

    def __truediv__(self, other):
        if other.amount == 0:
            raise ZeroDivisionError ('Попытка деления на "0"')
        return f'В результате деления получилось клеток: {self.amount // other.amount}'

    def make_order(self, k):
        self.k = k
        self.t = r'\n'
        self.st_1 = ('*'*self.k + self.t)*(self.amount // self.k) + ('*'*(self.amount % self.k))
        if not isinstance(k, int):
            raise TypeError('Только целое число. Исправте атрибут')
        return self.st_1


a = Call(25)
print(a.amount)
b = Call(7)
print(b.amount)
print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a.make_order(6))




